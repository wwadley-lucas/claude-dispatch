// templates/hook.js
// ---
// name: context-router
// description: Routes user prompts to matching skills via keyword/regex (Layer 1), context signals (Layer 1.5), and optional LLM fallback (Layer 2)
// event: UserPromptSubmit
// timeout: 10000
// ---
// Generated by claude-dispatch — https://github.com/lucaswadley/claude-dispatch
// "A router walks into a bar. The bartender says, 'We don't serve your type here.' The router replies, 'That's fine, I'll just redirect.'"

const { execFileSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");

// Config file path — looks for dispatch-rules.json next to .claude/hooks/
const RULES_PATH = path.join(__dirname, "..", "dispatch-rules.json");
const CACHE_PATH = path.join(__dirname, "..", ".dispatch-cache.json");
const HISTORY_PATH = path.join(__dirname, "..", ".dispatch-history.json");

function exit() {
  console.log(JSON.stringify({}));
  process.exit(0);
}

// --- Helpers ---

function readStdin() {
  try {
    const chunks = [];
    const buf = Buffer.alloc(65536);
    let bytesRead;
    while (true) {
      try {
        bytesRead = fs.readSync(0, buf, 0, buf.length);
        if (bytesRead === 0) break;
        chunks.push(buf.slice(0, bytesRead));
      } catch { break; }
    }
    return Buffer.concat(chunks).toString("utf8");
  } catch { return ""; }
}

function loadRules() {
  try {
    return JSON.parse(fs.readFileSync(RULES_PATH, "utf8"));
  } catch { return null; }
}

function hashPrompt(prompt, cwd) {
  return crypto.createHash("md5").update(prompt.slice(0, 200) + "|" + cwd).digest("hex");
}

function loadCache() {
  try { return JSON.parse(fs.readFileSync(CACHE_PATH, "utf8")); } catch { return {}; }
}

function saveCache(cache) {
  try { fs.writeFileSync(CACHE_PATH, JSON.stringify(cache), "utf8"); } catch {}
}

function pruneCache(cache, ttl) {
  const now = Date.now();
  const pruned = {};
  for (const [key, entry] of Object.entries(cache)) {
    if (now - entry.ts < ttl) pruned[key] = entry;
  }
  return pruned;
}

// --- Layer 1: Keyword/Regex Scoring ---

function scoreRule(rule, promptLower, promptRaw) {
  let score = 0;
  const matchedTerms = [];
  for (const kw of rule.keywords) {
    if (promptLower.includes(kw.toLowerCase())) { score += 1; matchedTerms.push(kw); }
  }
  for (const pat of rule.patterns) {
    try { if (new RegExp(pat, "i").test(promptRaw)) { score += 2; matchedTerms.push(`/${pat}/`); } } catch {}
  }
  return { score, matchedTerms };
}

function layer1Match(rules, config, prompt) {
  const promptLower = prompt.toLowerCase();
  const results = [];
  for (const rule of rules) {
    const { score, matchedTerms } = scoreRule(rule, promptLower, prompt);
    const threshold = rule.minMatches || config.minScore || 2;
    if (score >= threshold) {
      results.push({
        id: rule.id, name: rule.name, category: rule.category, command: rule.command,
        enforcement: rule.enforcement, description: rule.description,
        score, keywordScore: score, contextScore: 0, contextSignals: [], matchedTerms, layer: 1,
      });
    }
  }
  results.sort((a, b) => b.score - a.score);
  return results.slice(0, (config.maxMatches || 5) * 2);
}

// --- Layer 1.5: Context Signals ---

function detectDirectoryContext(cwd, directorySignals) {
  if (!directorySignals) return {};
  const boosts = {};
  for (const entry of directorySignals) {
    try {
      if (new RegExp(entry.pattern).test(cwd)) {
        for (const [cat, val] of Object.entries(entry.boosts)) { boosts[cat] = (boosts[cat] || 0) + val; }
      }
    } catch {}
  }
  return boosts;
}

function detectFileContext(cwd, fileTypeSignals) {
  if (!fileTypeSignals) return {};
  const boosts = {};
  try {
    const extCounts = {};
    for (const f of fs.readdirSync(cwd).slice(0, 50)) {
      const ext = path.extname(f).toLowerCase();
      if (ext) extCounts[ext] = (extCounts[ext] || 0) + 1;
    }
    for (const [ext, count] of Object.entries(extCounts)) {
      if (count >= 3 && fileTypeSignals[ext]) {
        for (const [cat, val] of Object.entries(fileTypeSignals[ext])) { boosts[cat] = (boosts[cat] || 0) + val; }
      }
    }
  } catch {}
  return boosts;
}

function detectProjectMarkers(cwd, projectMarkers) {
  if (!projectMarkers) return { boosts: {}, penalties: {} };
  const boosts = {};
  const penalties = {};
  const exists = (p) => { try { fs.accessSync(p); return true; } catch { return false; } };

  for (const marker of projectMarkers) {
    if (marker.file) {
      let found = false;
      let dir = cwd;
      for (let i = 0; i < 6; i++) {
        if (exists(path.join(dir, marker.file))) { found = true; break; }
        const parent = path.dirname(dir);
        if (parent === dir) break;
        dir = parent;
      }
      if (found && marker.boosts) {
        for (const [cat, val] of Object.entries(marker.boosts)) { boosts[cat] = (boosts[cat] || 0) + val; }
      }
    }
    if (marker.absent) {
      let found = false;
      let dir = cwd;
      for (let i = 0; i < 6; i++) {
        if (exists(path.join(dir, marker.absent))) { found = true; break; }
        const parent = path.dirname(dir);
        if (parent === dir) break;
        dir = parent;
      }
      if (!found && marker.penalties) {
        for (const [cat, val] of Object.entries(marker.penalties)) { penalties[cat] = (penalties[cat] || 0) + val; }
      }
    }
  }
  return { boosts, penalties };
}

function detectSessionSequence(skillSequences) {
  if (!skillSequences) return {};
  try {
    const hist = JSON.parse(fs.readFileSync(HISTORY_PATH, "utf8"));
    if (!hist.history || hist.history.length === 0) return {};
    const lastEntry = hist.history[hist.history.length - 1];
    if (Date.now() - lastEntry.ts > 2 * 60 * 60 * 1000) return {};
    const nextSkills = skillSequences[lastEntry.skill];
    if (!nextSkills) return {};
    const boosts = {};
    for (let i = 0; i < nextSkills.length; i++) { boosts[nextSkills[i]] = i === 0 ? 2 : 1; }
    return boosts;
  } catch { return {}; }
}

function applyContextSignals(matches, cwd, rulesConfig) {
  if (!matches || matches.length === 0) return matches;
  const dirBoosts = detectDirectoryContext(cwd, rulesConfig.directorySignals);
  const fileBoosts = detectFileContext(cwd, rulesConfig.fileTypeSignals);
  const { boosts: markerBoosts, penalties: markerPenalties } = detectProjectMarkers(cwd, rulesConfig.projectMarkers);
  const sequenceBoosts = detectSessionSequence(rulesConfig.skillSequences);

  for (const match of matches) {
    let ctxScore = 0;
    const signals = [];
    const cat = match.category;
    if (dirBoosts[cat]) { ctxScore += dirBoosts[cat]; signals.push(`dir:+${dirBoosts[cat]}`); }
    if (fileBoosts[cat]) { ctxScore += fileBoosts[cat]; signals.push(`files:+${fileBoosts[cat]}`); }
    if (markerBoosts[cat]) { ctxScore += markerBoosts[cat]; signals.push(`marker:+${markerBoosts[cat]}`); }
    if (markerPenalties[cat]) { ctxScore += markerPenalties[cat]; signals.push(`marker:${markerPenalties[cat]}`); }
    if (sequenceBoosts[match.command]) { ctxScore += sequenceBoosts[match.command]; signals.push(`seq:+${sequenceBoosts[match.command]}`); }
    match.contextScore = ctxScore;
    match.contextSignals = signals;
    match.score += ctxScore;
  }
  return matches;
}

// --- Layer 2: LLM Fallback ---

function layer2Match(rules, config, prompt) {
  const ruleList = rules.map((r) => `- ${r.id}: ${r.description}`).join("\n");
  const classifierPrompt =
    "You are a skill classifier. Given a user prompt, identify which skills (if any) are relevant. " +
    "Return ONLY a JSON array of matching skill IDs, or an empty array if none match.\n\n" +
    "Available skills:\n" + ruleList +
    "\n\nUser prompt: " + JSON.stringify(prompt.slice(0, 500)) +
    "\n\nReturn ONLY a JSON array like [\"skill-id-1\"] or []. No explanation.";

  try {
    const result = execFileSync("claude", ["--print", "-m", "haiku", "--max-tokens", "200"], {
      input: classifierPrompt, timeout: config.llmTimeout || 5000, encoding: "utf8", stdio: ["pipe", "pipe", "pipe"],
    });
    const match = result.match(/\[[\s\S]*?\]/);
    if (!match) return [];
    const ids = JSON.parse(match[0]);
    if (!Array.isArray(ids)) return [];
    const ruleMap = Object.fromEntries(rules.map((r) => [r.id, r]));
    return ids.filter((id) => ruleMap[id]).map((id) => {
      const rule = ruleMap[id];
      return {
        id: rule.id, name: rule.name, category: rule.category, command: rule.command,
        enforcement: rule.enforcement, description: rule.description,
        score: 0, keywordScore: 0, contextScore: 0, contextSignals: ["llm-classified"], matchedTerms: ["llm-classified"], layer: 2,
      };
    }).slice(0, config.maxMatches || 5);
  } catch { return []; }
}

// --- History ---

function recordTopMatch(command) {
  try {
    let hist;
    try { hist = JSON.parse(fs.readFileSync(HISTORY_PATH, "utf8")); } catch { hist = { history: [], pid: null }; }
    const pid = process.ppid || process.pid;
    if (hist.pid && hist.pid !== pid) { hist.history = []; }
    hist.pid = pid;
    hist.history.push({ skill: command, ts: Date.now() });
    if (hist.history.length > 10) { hist.history = hist.history.slice(-10); }
    fs.writeFileSync(HISTORY_PATH, JSON.stringify(hist), "utf8");
  } catch {}
}

// --- Output ---

function outputMatches(matches) {
  console.log(JSON.stringify({
    contextRouter: {
      matched: true,
      matchCount: matches.length,
      matches: matches.map((m) => ({
        id: m.id, name: m.name, command: m.command, enforcement: m.enforcement,
        description: m.description, score: m.score, keywordScore: m.keywordScore,
        contextScore: m.contextScore, contextSignals: m.contextSignals, layer: m.layer,
      })),
      instruction:
        "Present these matched skills to the user for confirmation before activating. " +
        "Only invoke Skill tool for skills the user explicitly approves. " +
        "If enforcement is 'block', require explicit acknowledgment. " +
        "If enforcement is 'silent', mention the skill without requiring action.",
    },
  }));
}

// --- Main ---

function main() {
  try {
    const input = readStdin();
    if (!input) return exit();
    let data;
    try { data = JSON.parse(input); } catch { return exit(); }

    const prompt = data.user_prompt || "";
    const cwd = data.cwd || process.cwd();
    if (!prompt || prompt.length < 10) return exit();
    if (prompt.startsWith("/")) return exit();

    const rulesFile = loadRules();
    if (!rulesFile || !rulesFile.rules) return exit();
    const { config, rules } = rulesFile;

    // Cache check
    const hash = hashPrompt(prompt, cwd);
    let cache = loadCache();
    cache = pruneCache(cache, config.cacheTTL || 300000);
    if (cache[hash]) {
      const cached = cache[hash].matches;
      if (cached.length > 0) { recordTopMatch(cached[0].command); outputMatches(cached); }
      return exit();
    }

    // Layer 1
    let matches = layer1Match(rules, config, prompt);

    // Layer 1.5
    if (matches.length > 0) {
      matches = applyContextSignals(matches, cwd, rulesFile);
      matches.sort((a, b) => b.score - a.score);
      matches = matches.slice(0, config.maxMatches || 5);
    }

    // Layer 2
    if (matches.length === 0 && config.llmFallback) {
      matches = layer2Match(rules, config, prompt);
    }

    if (matches.length > 0) { recordTopMatch(matches[0].command); }
    cache[hash] = { ts: Date.now(), matches };
    saveCache(cache);
    if (matches.length > 0) { outputMatches(matches); } else { exit(); }
  } catch { exit(); }
}

main();
